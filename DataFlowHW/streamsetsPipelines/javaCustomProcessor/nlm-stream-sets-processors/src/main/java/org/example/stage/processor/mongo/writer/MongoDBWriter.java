
package org.example.stage.processor.mongo.writer;

import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.ReplaceOptions;
import com.streamsets.pipeline.api.Record;
import com.streamsets.pipeline.api.StageException;
import com.streamsets.pipeline.api.base.SingleLaneRecordProcessor;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.example.stage.lib.sample.Errors;
import org.example.stage.processor.mongo.uuid.generator.UUIDGeneratorProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Properties;

import static com.mongodb.client.model.Filters.eq;

public abstract class MongoDBWriter extends SingleLaneRecordProcessor {
    private static final Logger LOG = LoggerFactory.getLogger(MongoDBWriter.class);

    /**
     * Gives access to the UI configuration of the stage provided by the {@link SampleDProcessor} class.
     */
    public abstract String getConfig();

    /**
     * {@inheritDoc}
     */
    @Override
    protected List<ConfigIssue> init() {
        // Validate configuration values and open any required resources.
        List<ConfigIssue> issues = super.init();

        if (getConfig().equals("invalidValue")) {
            issues.add(
                    getContext().createConfigIssue(
                            Groups.SAMPLE.name(), "config", Errors.SAMPLE_00, "Here's what's wrong..."
                    )
            );
        }

        // If issues is not empty, the UI will inform the user of each configuration issue in the list.
        return issues;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void destroy() {
        // Clean up any open resources.
        super.destroy();
    }

    /**
     * Connects to mongoDB and insert or replace a {@link Document}
     * according UUID generated by {@link UUIDGeneratorProcessor}
     *
     * @param record     the record to process
     * @param batchMaker to add the record
     * @throws StageException if had an error while processing records
     */
    @Override
    protected void process(Record record, SingleLaneBatchMaker batchMaker) throws StageException {
        LOG.info("Processing a record: {}", record);

        final Properties mongoProperties = loadProperties("mongo-db-connection.properties");

        final String dbConnection = mongoProperties.getProperty("db.connection");
        final String dbName = mongoProperties.getProperty("db.name");
        final String dbCollection = mongoProperties.getProperty("db.raw.collection");
        final String recordPathToRawJson = "/articleJson";
        final String recordPathToUUID = "/_id";

        try (MongoClient mongoClient = MongoClients.create(dbConnection)) {
            final MongoDatabase sampleTrainingDB = mongoClient.getDatabase(dbName);
            final MongoCollection<Document> rawCollection = sampleTrainingDB.getCollection(dbCollection);

            final String rawJson = record.get(recordPathToRawJson).getValueAsString();
            final String uuid = record.get(recordPathToUUID).getValueAsString();

            final Bson filter = eq("_id", uuid);
            final Document document = new Document("_id", uuid);
            document.append("article", (Document.parse(rawJson)));
            rawCollection.replaceOne(filter, document, new ReplaceOptions().upsert(true));

            LOG.info("article with {} id has been written in {} collection", uuid, dbCollection);
        }

        record.delete(recordPathToRawJson);

        batchMaker.addRecord(record);
    }

    private Properties loadProperties(String propertyName) {
        Properties properties = new Properties();
        try (InputStream input = MongoDBWriter.class.getClassLoader().getResourceAsStream(propertyName)) {

            if (input == null) {
                LOG.error("Can not find property : {}", "mongo-db-connection.properties");
            }

            properties.load(input);

        } catch (IOException ex) {
            ex.printStackTrace();
        }
        return properties;
    }

}


